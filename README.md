## Введение 

Множество — одно из ключевых понятий математики, в частности, теории множеств и логики. С множествами можно проводить ряд операций, а именно: объединение, пересечение, дополнение, добавление и удаление элемента. Активное применение аппарата теории множеств в современной науке приводит к необходимости создания соответствующих программных решений. Программная реализация множества может выполняться различными способами (в соответствии с требованиями конкретной задачи или с общих позиций) и обычно тесно связана с использованием битовых операций. Данная работа посвящена изучению и реализации одного из возможных подходов к хранению и обработке множеств



## Связь между битовым полем и множеством
Битовое поле позволяет нам сэкономить в разы больше памяти, в сравнении с обычным массивом. И за счет него, куда практичнее хранить множества. Битовое поле представляет из себя набор нулей и единиц. Все что нужно сделать, это лишь поставить единицы в нужные места. Для начала присвоим каждому элементу множества свой уникальный номер от 0 до максимального значения непрерывным диапазоном целых чисел. Далее работаем с номерами. Допустим во множестве есть элемент i, нам необходимо на i-тую позицию битового поставить единицу. 



иллюстрирует битовое поле, множества {2,4,7}


## Постановка учебно-практической задачи 
Передо мной была поставлена учебно-практическая задача, заключающаяся в написании реализации классов “Битовое поле” и “Множество” и тестов для проверки работоспособности программы.

## Руководство пользователя :smiling_imp:
Для проверки работоспособности программы выполните следующие действия : 

1. Запустите программу с помощью комбинации клавиш ctrl + F5 
2. Введите максимальный элемент первого множества, а затем и его элементы
3. Чтобы закончить ввод элементов введите Enter
4. Введите максимальный элемент второго множества, а затем и его элементы 
5. Чтобы закончить ввод элементов введите Enter
6. Посмотрите на результат работы программы, который будет выведен автоматически после ввода обоих множеств.
7. Введите элемент, который хотите удалить из множества. 
8. Введите элемент, который хотите добавить к первому множеству.
9. Введите элемент который хотите найти в первом множестве.
10. Посмотрите на результат работы программы.



## Руководство программиста :innocent:
Методы классов “Битовое поле” и “Множество”, описание алгоритмов.

*Класс Bit включает в себя следующие методы:*
```private:
	int get_index(const int n) const
	int get_bit_mask(const int n) const
public:
	Bit();
	Bit(const int n);
	Bit(const Bit& b2);
	~Bit()
	int get_size()
	void set_bit(const int n);
	void clr_bit(const int n);
	int get_bit(const int n);
	bool operator ==(const Bit& b2);
	void operator =(const Bit& b2);
	Bit operator &(const Bit& b2);
	Bit operator |(const Bit& b2);
	Bit operator~();
	friend ostream& operator<<(ostream& ofstr, const Bit& b2);
  friend istream& operator>>(istream& ifstr, Bit& b2);
```
*Класс Set включает в себя следующие методы:*
```
public:
	Set(int el);
	Set(const Set& mn);
	Set(Bit& bp);
	operator Bit();

	void add(const int el);
	void del(const int el);
	void clr_set();

	Set unionn(const Set& mn);
	Set intersectionl(const Set& mn);
	Set complement();
	bool compare(const Set& mn);
	bool belong(const int el);

	friend istream& operator >>(istream& is, Set& op2);
	friend ostream& operator <<(ostream& of, Set& op2);
```

## Описание алгоритмов (Bit)
+ int get_index(const int n) const  Узнает,в каком элементе массива arr содержится заданный нами элемент битового поля. Возвращает индекс этого элемента. Для этого сдвигаем его побитово вправо на 5

+ int get_bit_mask const Возвращает значение (битовую маску) , в котором ненулевым будет только один n-й бит. 
Для этого берем единицу и сдвигаем ее побитово вправо на (n & 31);

+ Bit(const int n) Конструктор. Создает битовое поле длины len. 

+ Bit(const Bit& b2); Конструктор копирования. Создает новое битовое поле, в которое копирует данные уже существующего битового поля b2. 

+ ~Bit(); Деструктор. Освобождает память для arr. 

+ void set_bit(const int n) Устанавливает значением бита n единицу в get_index(n). Происходит битовое сложение с get_bit_mask(n) (битовой маской). 

+ void void clr_bit(const int n)) Устанавливает значением бита n ноль в get_index(n. Происходит битовое умножение с отрицанием  get_bit_mask(n). 

+ int get_bit(const int n) const Возвращает значение бита n. Происходит битовое умножение элемента get_index(n). на get_bit_mask(n). 


+ bool operator ==(const Bit& b2); Перегрузка оператора “сравнение”. Возвращает true, если элементы массива arr равны. В противном случае возвращает false. 

+ void operator =(const Bit& b2); Приравнивает поля друг к другу.

+ Bit operator |(const Bit& b2); Перегрузка оператора “or” - “Логическое или”. Возвращает результат выполнения этой операции между элементами массивов arr и b2.arr. 

+ Bit operator &(const Bit& b2);  Перегрузка оператора “and” - “Логическое и”. Возвращает результат выполнения этой операции между элементами массивов arr и b2.arr. 

+ Bit operator~(); Перегрузка оператора “not” - “Логическое отрицание”. Для каждого бита выполняется : значение ==1 - записываем 0; значение ==0 - записываем 1. 
*Класс “Множество” построен на основе битового поля Bit. В нём используются методы для работы с его битовыми полями.*

## Описание алгоритмов (Set)
+ Set(int el) Конструктор. Создает множество длины len.

+ Set(const Set& mn)	 Конструктор копирования. Создает новое множество е, в которое копирует данные уже существующего множества mn.

+ Set(Bit& bp) Конструктор. Создает новое множество е, в которое копирует данные уже битового поля bp.

+ void add(const int el) добавляет заданное значение во множество.

+ void del(const int el) удаляет заданное значение из множества.

+ void clr_set() очищает множество. Удаляет из него все элементы .

+ Set unionn(const Set& mn) объединяет множество и возвращает множество со всеми элементами из данных двух, без повторений.

+ Set intersectionl(const Set& mn) пересекает множество и возвращает множество с общими элементами из данных двух.

+ Set complement() дополняет множество

+ bool compare(const Set& mn) сравнивает множества

+ bool belong(const int el) говорит, есть ли заданный элемент во множестве



## Заключение 
В процессе выполнения лабораторной работы мной была написана и протестирована реализация классов “Битовое поле” и “Множество”. 
